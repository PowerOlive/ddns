#!/usr/bin/env python
# coding:utf-8

PY3 = '' is u''
if not PY3:
    reload(__import__('sys')).setdefaultencoding('utf-8')

import sys
import base64
import email.utils
import getopt
import hashlib
import json
import logging
import os
import re
import socket
import hmac
import sys
import uuid
import threading
import time

if PY3:
    from urllib.parse import urlencode, quote_plus
    from urllib.request import urlopen, Request, HTTPError
    from queue import Queue
    from itertools import zip_longest
else:
    from urllib import urlencode, quote_plus
    from urllib2 import urlopen, Request, HTTPError
    from Queue import Queue
    from itertools import izip_longest as zip_longest

logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.INFO)


def _getip():
    urls = [
        'http://ip.3322.org',
        'http://whatismyip.akamai.com/',
        'http://checkip.amazonaws.com/',
    ]
    result = Queue()
    def _fetch(url):
        result.put(urlopen(Request(url, headers={'user-agent':'curl/7.53'}), timeout=5))
        logging.info('getip() from %r', url)
    for url in urls:
        t = threading.Thread(target=_fetch, args=(url,))
        t.setDaemon(True)
        t.start()
    text = result.get().read().decode()
    ip = re.search(r'(\d{1,3}.){3}\d{1,3}', text).group()
    return ip


def cloudxns(key, secret, domain):
    ip = _getip()
    if ip == socket.gethostbyname(domain):
        logging.info('remote ip and local ip is same to %s, exit.', ip)
        return
    api_url = 'https://www.cloudxns.net/api2/ddns'
    data = json.dumps({'domain': domain, 'ip': ip, 'line_id': '1'})
    date = email.utils.formatdate()
    api_hmac = hashlib.md5(''.join((key, api_url, data, date, secret)).encode()).hexdigest()
    headers = {'API-KEY': key, 'API-REQUEST-DATE': date, 'API-HMAC': api_hmac, 'API-FORMAT': 'json'}
    resp = urlopen(Request(api_url, data=data.encode(), headers=headers), timeout=5)
    logging.info('cloudxns domain=%r to ip=%r result: %s', domain, ip, resp.read())


def cloudflare(email, key, zone, record_name):
    ip = _getip()
    if ip == socket.gethostbyname(record_name):
        logging.info('remote ip and local ip is same to %s, exit.', ip)
        return
    headers = {'X-Auth-Email': email, 'X-Auth-Key': key, 'Content-Type': 'application/json'}
    if '.' not in zone:
        zone_name = zone
        zone_id = zone
    else:
        zone_name = zone
        api_url = 'https://api.cloudflare.com/client/v4/zones?name=%s' % zone_name
        resp = urlopen(Request(api_url, headers=headers), timeout=5)
        zone_id = json.loads(resp.read().decode())['result'][0]['id']
    if '.' not in record_name:
        record_id = record_name
    else:
        api_url = 'https://api.cloudflare.com/client/v4/zones/%s/dns_records?name=%s' % (zone_id, record_name)
        resp = urlopen(Request(api_url, headers=headers), timeout=5)
        record_id = json.loads(resp.read().decode())['result'][0]['id']
    api_url = 'https://api.cloudflare.com/client/v4/zones/%s/dns_records/%s' % (zone_id, record_id)
    data = json.dumps({'id': zone_id, 'type': 'A', 'ttl': 300, 'proxied': False, 'name': record_name, 'content': ip})
    req = Request(api_url, data=data.encode(), headers=headers)
    req.get_method = lambda: 'PUT'
    logging.info('cloudflare updating record_name=%r to ip=%r', record_name, ip)
    resp = urlopen(req, timeout=5)
    logging.info('cloudflare record_name=%r to ip=%r result: %s', record_name, ip, resp.read())


def aliyun(key, secret, domain):
    ip = _getip()
    if ip == socket.gethostbyname(domain):
        logging.info('remote ip and local ip is same to %s, exit.', ip)
        return
    sign = lambda p: base64.b64encode(hmac.new((secret+'&').encode(), ('GET&%2F&'+quote_plus(urlencode(sorted(p)))).encode(), hashlib.sha1).digest())
    api_url = 'https://alidns.aliyuncs.com/?'
    rr, root_domain = domain.split('.', 1)
    params = [
        ('Format', 'json'),
        ('Version', '2015-01-09'),
        ('AccessKeyId', key),
        ('Timestamp', time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime())),
        ('SignatureMethod', 'HMAC-SHA1'),
        ('SignatureNonce', uuid.uuid4()),
        ('SignatureVersion', '1.0'),
        ('Action', 'DescribeDomainRecords'),
        ('DomainName', root_domain),
    ]
    params += [('Signature', sign(params))]
    resp = urlopen(Request(api_url + urlencode(sorted(params))), timeout=5)
    info = json.loads(resp.read())
    record_id = next(x['RecordId'] for x in info['DomainRecords']['Record'] if x['RR'] == rr)
    logging.info('aliyun domain=%r to ip=%r record_id: %s', domain, ip, record_id)
    params = [
        ('Format', 'json'),
        ('Version', '2015-01-09'),
        ('AccessKeyId', key),
        ('Timestamp', time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime())),
        ('SignatureMethod', 'HMAC-SHA1'),
        ('SignatureNonce', uuid.uuid4()),
        ('SignatureVersion', '1.0'),
        ('Action', 'UpdateDomainRecord'),
        ('RecordId', record_id),
        ('RR', rr),
        ('Type', 'A'),
        ('Value', ip),
        ('TTL', 600),
    ]
    params += [('Signature', sign(params))]
    try:
        result = urlopen(Request(api_url + urlencode(sorted(params))), timeout=5).read()
    except HTTPError as e:
        result = e.read()
    logging.info('aliyun domain=%r to ip=%r result: %s', domain, ip, result)


def gandi(key, zone, record_name):
    ip = _getip()
    if ip == socket.gethostbyname(record_name):
        logging.info('remote ip and local ip is same to %s, exit.', ip)
        return
    headers = {'X-Api-Key': key, 'Content-Type': 'application/json'}
    if '.' not in zone:
        zone_name = zone
        zone_id = zone
    else:
        zone_name = zone
        api_url = 'https://dns.api.gandi.net/api/v5/zones'
        resp = urlopen(Request(api_url, headers=headers), timeout=5)
        zone_id = next(x['uuid'] for x in json.loads(resp.read().decode()) if x['name'] == zone_name)
    if record_name.endswith(zone_name):
        record_name = record_name[:-len(zone_name)].strip('.')
    if record_name == '':
        record_name = '@'
    api_url = 'https://dns.api.gandi.net/api/v5/zones/%s/records/%s/A' % (zone_id, record_name)
    data = json.dumps({'rrset_ttl': 300, 'rrset_values': [ip]})
    req = Request(api_url, data=data.encode(), headers=headers)
    req.get_method = lambda: 'PUT'
    logging.info('gandi updating record_name=%r to ip=%r', record_name, ip)
    resp = urlopen(req, timeout=5)
    logging.info('gandi record_name=%r to ip=%r result: %s', record_name, ip, resp.read())


def __main():
    applet = os.path.basename(sys.argv[0])
    funcs = [v for v in globals().values() if type(v) is type(__main) and v.__module__ == '__main__' and not v.__name__.startswith('_')]
    if not PY3:
        for func in funcs:
            setattr(func, '__doc__', getattr(func, 'func_doc'))
            setattr(func, '__defaults__', getattr(func, 'func_defaults'))
            setattr(func, '__code__', getattr(func, 'func_code'))
    funcs = sorted(funcs, key=lambda x:x.__name__)
    params = dict((f.__name__, list(zip_longest(f.__code__.co_varnames[:f.__code__.co_argcount][::-1], (f.__defaults__ or [])[::-1]))[::-1]) for f in funcs)
    def usage(applet):
        if applet in ('ddns', 'ddns.py'):
            print('Usage: {0} <provider> [arguments]\n\nExamples:\n{1}\n'.format(applet, '\n'.join('\t{0} {1} {2}'.format(applet, k, ' '.join('--{0} {1}'.format(x.replace('_', '-'), x.upper() if y is None else repr(y)) for (x, y) in v)) for k, v in params.items())))
        else:
            print('\nUsage:\n\t{0} {1}'.format(applet, ' '.join('--{0} {1}'.format(x.replace('_', '-'), x.upper() if y is None else repr(y)) for (x, y) in params[applet])))
    if '-h' in sys.argv or '--help' in sys.argv or (applet in ('ddns', 'ddns.py') and not sys.argv[1:]):
        return usage(applet)
    if applet in ('ddns', 'ddns.py'):
        applet = sys.argv[1]
    for f in funcs:
        if f.__name__ == applet:
            break
    else:
        return usage()
    options = [x.replace('_','-')+'=' for x in f.__code__.co_varnames[:f.__code__.co_argcount]]
    kwargs, _ =  getopt.gnu_getopt(sys.argv[1:], '', options)
    kwargs = dict((k[2:].replace('-', '_'),v) for k, v in kwargs)
    logging.debug('main %s(%s)', f.__name__, kwargs)
    try:
        result = f(**kwargs)
    except TypeError as e:
        patterns = [r'missing \d+ .* argument', r'takes (\w+ )+\d+ argument']
        if any(re.search(x, str(e)) for x in patterns):
            return usage(applet)
        raise
    if type(result) == type(b''):
        result = result.decode().strip()
    if result:
        print(result)


if __name__ == '__main__':
    __main()

