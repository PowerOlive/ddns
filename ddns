#!/usr/bin/env python
# coding:utf-8

PY3 = '' is u''
if not PY3:
    reload(__import__('sys')).setdefaultencoding('utf-8')

import base64
import collections
import email.utils
import getopt
import hashlib
import hmac
import json
import logging
import os
import re
import socket
import sys
import sys
import threading
import time
import uuid

if PY3:
    from itertools import zip_longest
    from queue import Queue
    from urllib.parse import urlencode, quote_plus
    from urllib.request import urlopen, Request, HTTPError
else:
    from itertools import izip_longest as zip_longest
    from Queue import Queue
    from urllib import urlencode, quote_plus
    from urllib2 import urlopen, Request, HTTPError

logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.INFO)


def aliyun(key, secret, domain):
    ip = _getip()
    if ip == socket.gethostbyname(domain):
        logging.info('remote ip and local ip is same to %s, exit.', ip)
        return
    rfc3339 = lambda: time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime())
    sign = lambda p: base64.b64encode(hmac.new((secret+'&').encode(), ('GET&%2F&'+quote_plus(urlencode(sorted(p)))).encode(), hashlib.sha1).digest())
    api_url = 'https://alidns.aliyuncs.com/?'
    rr, root_domain = _split(domain)
    params = [
        ('Format', 'json'),
        ('Version', '2015-01-09'),
        ('AccessKeyId', key),
        ('Timestamp', rfc3339()),
        ('SignatureMethod', 'HMAC-SHA1'),
        ('SignatureNonce', uuid.uuid4()),
        ('SignatureVersion', '1.0'),
        ('Action', 'DescribeDomainRecords'),
        ('DomainName', root_domain),
    ]
    params += [('Signature', sign(params))]
    resp = urlopen(Request(api_url + urlencode(sorted(params))), timeout=5)
    info = json.loads(resp.read())
    record_id = next(x['RecordId'] for x in info['DomainRecords']['Record'] if x['RR'] == rr)
    logging.info('aliyun domain=%r to ip=%r record_id: %s', domain, ip, record_id)
    params = [
        ('Format', 'json'),
        ('Version', '2015-01-09'),
        ('AccessKeyId', key),
        ('Timestamp', rfc3339()),
        ('SignatureMethod', 'HMAC-SHA1'),
        ('SignatureNonce', uuid.uuid4()),
        ('SignatureVersion', '1.0'),
        ('Action', 'UpdateDomainRecord'),
        ('RecordId', record_id),
        ('RR', rr),
        ('Type', 'A'),
        ('Value', ip),
        ('TTL', 600),
    ]
    params += [('Signature', sign(params))]
    try:
        result = urlopen(Request(api_url + urlencode(sorted(params))), timeout=5).read()
    except HTTPError as e:
        result = e.read()
    logging.info('aliyun domain=%r to ip=%r result: %s', domain, ip, result)


def cloudflare(email, key, domain):
    ip = _getip()
    if ip == socket.gethostbyname(domain):
        logging.info('remote ip and local ip is same to %s, exit.', ip)
        return
    headers = {'X-Auth-Email': email, 'X-Auth-Key': key, 'Content-Type': 'application/json'}
    _, zone_name = _split(domain)
    api_url = 'https://api.cloudflare.com/client/v4/zones?name=%s' % zone_name
    resp = urlopen(Request(api_url, headers=headers), timeout=5)
    zone_id = json.loads(resp.read().decode())['result'][0]['id']
    api_url = 'https://api.cloudflare.com/client/v4/zones/%s/dns_records?name=%s' % (zone_id, domain)
    resp = urlopen(Request(api_url, headers=headers), timeout=5)
    record_id = json.loads(resp.read().decode())['result'][0]['id']
    api_url = 'https://api.cloudflare.com/client/v4/zones/%s/dns_records/%s' % (zone_id, record_id)
    data = json.dumps({'id': zone_id, 'type': 'A', 'ttl': 300, 'proxied': False, 'name': domain, 'content': ip})
    req = Request(api_url, data=data.encode(), headers=headers)
    req.get_method = lambda: 'PUT'
    logging.info('cloudflare updating domain=%r to ip=%r', domain, ip)
    resp = urlopen(req, timeout=5)
    logging.info('cloudflare domain=%r to ip=%r result: %s', domain, ip, resp.read())


def cloudxns(key, secret, domain):
    ip = _getip()
    if ip == socket.gethostbyname(domain):
        logging.info('remote ip and local ip is same to %s, exit.', ip)
        return
    api_url = 'https://www.cloudxns.net/api2/ddns'
    data = json.dumps({'domain': domain, 'ip': ip, 'line_id': '1'})
    date = email.utils.formatdate()
    api_hmac = hashlib.md5(''.join((key, api_url, data, date, secret)).encode()).hexdigest()
    headers = {'API-KEY': key, 'API-REQUEST-DATE': date, 'API-HMAC': api_hmac, 'API-FORMAT': 'json'}
    resp = urlopen(Request(api_url, data=data.encode(), headers=headers), timeout=5)
    logging.info('cloudxns domain=%r to ip=%r result: %s', domain, ip, resp.read())


def dnspod(email, password, domain):
    ip = _getip()
    if ip == socket.gethostbyname(domain):
        logging.info('remote ip and local ip is same to %s, exit.', ip)
        return
    record_name, domain = _split(domain)
    params = {'login_email': email, 'login_password': password, 'format': 'json'}
    resp = urlopen(Request('https://dnsapi.cn/Domain.List', data=urlencode(params).encode()), timeout=5)
    info = json.loads(resp.read())
    domain_id = next(x['id'] for x in info['domains'] if x['punycode'] == domain)
    logging.info('dnspod domain=%r to ip=%r domain_id: %s', domain, ip, domain_id)
    params['domain_id'] = domain_id
    resp = urlopen(Request('https://dnsapi.cn/Record.List', data=urlencode(params).encode()), timeout=5)
    info = json.loads(resp.read())
    record_id = next(x['id'] for x in info['records'] if x['name'] == record_name and x['type'] == 'A')
    logging.info('dnspod domain=%r to ip=%r record_id: %s', domain, ip, record_id)
    params.update({
        'record_id': record_id,
        'record_type': 'A',
        'record_line': u'默认',
        'value': ip,
        'mx': 5,
        'sub_domain': record_name,
    })
    resp = urlopen(Request('https://dnsapi.cn/Record.Modify', data=urlencode(params).encode()), timeout=5)
    info = json.loads(resp.read())
    logging.info('dnspod domain=%r to ip=%r info: %s', domain, ip, info)


def gandi(key, domain):
    ip = _getip()
    if ip == socket.gethostbyname(domain):
        logging.info('remote ip and local ip is same to %s, exit.', ip)
        return
    headers = {'X-Api-Key': key, 'Content-Type': 'application/json'}
    record_name, zone_name = _split(domain)
    api_url = 'https://dns.api.gandi.net/api/v5/zones'
    resp = urlopen(Request(api_url, headers=headers), timeout=5)
    zone_id = next(x['uuid'] for x in json.loads(resp.read().decode()) if x['name'] == zone_name)
    api_url = 'https://dns.api.gandi.net/api/v5/zones/%s/records/%s/A' % (zone_id, record_name)
    data = json.dumps({'rrset_ttl': 300, 'rrset_values': [ip]})
    req = Request(api_url, data=data.encode(), headers=headers)
    req.get_method = lambda: 'PUT'
    logging.info('gandi updating domain=%r to ip=%r', domain, ip)
    resp = urlopen(req, timeout=5)
    logging.info('gandi domain=%r to ip=%r result: %s', domain, ip, resp.read())


def he(key, domain):
    ip = _getip()
    if ip == socket.gethostbyname(domain):
        logging.info('remote ip and local ip is same to %s, exit.', ip)
        return
    params = {'hostname': domain, 'password': key, 'myip': ip}
    resp = urlopen(Request('https://dyn.dns.he.net/nic/update', data=urlencode(params).encode()), timeout=5)
    logging.info('dnspod domain=%r to ip=%r result: %s', domain, ip, resp.read())


def _getip():
    urls = [
        'http://ip.3322.org',
        'http://whatismyip.akamai.com/',
        'http://checkip.amazonaws.com/',
    ]
    result = Queue()
    def _fetch(url):
        result.put(urlopen(Request(url, headers={'user-agent':'curl/7.53'}), timeout=5))
        logging.info('getip() from %r', url)
    for url in urls:
        t = threading.Thread(target=_fetch, args=(url,))
        t.setDaemon(True)
        t.start()
    text = result.get().read().decode()
    ip = re.search(r'(\d{1,3}.){3}\d{1,3}', text).group()
    return ip


def _split(domain):
    root = '.'.join(domain.rsplit('.', 2)[-2:])
    record = domain[:-len(root)].strip('.') or '@'
    return record, root


def _main():
    applet = os.path.basename(sys.argv[0])
    funcs = [v for v in globals().values() if type(v) is type(_main) and v.__module__ == '__main__' and not v.__name__.startswith('_')]
    if not PY3:
        for func in funcs:
            setattr(func, '__doc__', getattr(func, 'func_doc'))
            setattr(func, '__defaults__', getattr(func, 'func_defaults'))
            setattr(func, '__code__', getattr(func, 'func_code'))
    funcs = sorted(funcs, key=lambda x:x.__name__)
    params = collections.OrderedDict((f.__name__, list(zip_longest(f.__code__.co_varnames[:f.__code__.co_argcount][::-1], (f.__defaults__ or [])[::-1]))[::-1]) for f in funcs)
    def usage(applet):
        if applet in ('ddns', 'ddns.py'):
            print('Usage: {0} <provider> [arguments]\n\nExamples:\n{1}\n'.format(applet, '\n'.join('\t{0} {1} {2}'.format(applet, k, ' '.join('--{0} {1}'.format(x.replace('_', '-'), x.upper() if y is None else repr(y)) for (x, y) in v)) for k, v in params.items())))
        else:
            print('\nUsage:\n\t{0} {1}'.format(applet, ' '.join('--{0} {1}'.format(x.replace('_', '-'), x.upper() if y is None else repr(y)) for (x, y) in params[applet])))
    if '-h' in sys.argv or '--help' in sys.argv or (applet in ('ddns', 'ddns.py') and not sys.argv[1:]):
        return usage(applet)
    if applet in ('ddns', 'ddns.py'):
        applet = sys.argv[1]
    for f in funcs:
        if f.__name__ == applet:
            break
    else:
        return usage()
    options = [x.replace('_','-')+'=' for x in f.__code__.co_varnames[:f.__code__.co_argcount]]
    kwargs, _ =  getopt.gnu_getopt(sys.argv[1:], '', options)
    kwargs = dict((k[2:].replace('-', '_'),v) for k, v in kwargs)
    logging.debug('main %s(%s)', f.__name__, kwargs)
    try:
        result = f(**kwargs)
    except TypeError as e:
        patterns = [r'missing \d+ .* argument', r'takes (\w+ )+\d+ argument']
        if any(re.search(x, str(e)) for x in patterns):
            return usage(applet)
        raise
    if type(result) == type(b''):
        result = result.decode().strip()
    if result:
        print(result)


if __name__ == '__main__':
    _main()

